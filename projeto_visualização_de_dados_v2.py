# -*- coding: utf-8 -*-
"""Projeto - Visualização de dados - V2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nnn2OO9QkatF5RER13K8-SkZxD2x42ag
"""

import pandas as pd
import numpy as np
import plotly.express as px
from dash import Dash, dcc, html, Input, Output
import math

DesempenhoAI = pd.read_csv('ideb_ai_2023.CSV', sep=';', encoding = "utf-8") # anos iniciais
DesempenhoAF = pd.read_csv('ideb_af_2023.CSV', sep=';', encoding = "iso-8859-1") # anos finais
DesempenhoEM = pd.read_csv('ideb_em_2023.CSV', sep=';', encoding = "iso-8859-1") # ensino médio

DesempenhoAI['NIVEL'] = 'Anos Iniciais'  # Anos Iniciais
DesempenhoAI = DesempenhoAI.reindex()
DesempenhoAF['NIVEL'] = 'Anos Finais'  # Anos Finais
DesempenhoEM['NIVEL'] = 'Ensino Médio'  # Ensino Médio
DesempenhoTotal = pd.concat([DesempenhoAI, DesempenhoAF, DesempenhoEM], ignore_index=True)

DesempenhoTotal.loc[DesempenhoTotal['UNIDGEO'] == 'R. G. do Sul', 'UNIDGEO'] = 'Rio Grande do Sul'
DesempenhoTotal.loc[DesempenhoTotal['UNIDGEO'] == 'R. G. do Norte', 'UNIDGEO'] = 'Rio Grande do Norte'
DesempenhoTotal.loc[DesempenhoTotal['UNIDGEO'] == 'M. G. do Sul', 'UNIDGEO'] = 'Mato Grosso do Sul'

# Remove as regiões
DesempenhoTotal = DesempenhoTotal[DesempenhoTotal['UNIDGEO'] != 'Norte']
DesempenhoTotal = DesempenhoTotal[DesempenhoTotal['UNIDGEO'] != 'Nordeste']
DesempenhoTotal = DesempenhoTotal[DesempenhoTotal['UNIDGEO'] != 'Centro-Oeste']
DesempenhoTotal = DesempenhoTotal[DesempenhoTotal['UNIDGEO'] != 'Sudeste']
DesempenhoTotal = DesempenhoTotal[DesempenhoTotal['UNIDGEO'] != 'Sul']

DesempenhoTotal = DesempenhoTotal[DesempenhoTotal['NO_DEPENDENCIA'].str.contains('Total')]
DesempenhoTotal = DesempenhoTotal.drop(columns=['NO_DEPENDENCIA'])

cols = DesempenhoTotal.columns.tolist()
# Mova 'NIVEL' para o início da lista
cols.insert(0, cols.pop(cols.index('NIVEL')))
# Reordene o DataFrame
DesempenhoTotal = DesempenhoTotal.reindex(columns=cols)


for col in cols:
  if col != 'UNIDGEO' and col != 'NO_DEPENDENCIA' and col != 'NIVEL':
    DesempenhoTotal[col] = DesempenhoTotal[col].replace('-', float('nan'))  # Substitui '-' por NaN
    DesempenhoTotal[col] = DesempenhoTotal[col].str.replace(',', '.').astype(float)  # Converte para float

styleDict = {"background-color": "white", "padding": "10px", "fontFamily": "Arial", "color": "#263f5d"}

Desempenho = DesempenhoTotal[[*DesempenhoTotal.columns[:3], *[col for col in DesempenhoTotal.columns if 'OBSERVADO' in col or 'PROJECAO' in col]]]
df = Desempenho

# Transformar as colunas de valores observados e projetados para formato longo
observado = df.melt(
    id_vars=["UNIDGEO", "NIVEL"],
    value_vars=[col for col in df.columns if "VL_OBSERVADO" in col],
    var_name="Ano",
    value_name="Observado",
)
projecao = df.melt(
    id_vars=["UNIDGEO", "NIVEL"],
    value_vars=[col for col in df.columns if "VL_PROJECAO" in col],
    var_name="Ano",
    value_name="Projetado",
)

# Ajustar a coluna de anos para conter apenas o número
observado["Ano"] = observado["Ano"].str.extract(r"(\d+)")
projecao["Ano"] = projecao["Ano"].str.extract(r"(\d+)")

# Combinar os dados em um único DataFrame
long_df = pd.merge(
    observado,
    projecao,
    on=["UNIDGEO", "NIVEL", "Ano"],
    how="inner",
)

long_df = long_df.sort_values(by=["UNIDGEO", "Ano"], ascending=[True, True])

Aprovacao = DesempenhoTotal[[*DesempenhoTotal.columns[:3], *[col for col in DesempenhoTotal.columns if 'APROVACAO' in col and 'SI_4' in col]]]

Aprovacao = Aprovacao.melt(
    id_vars=["UNIDGEO", "NIVEL"],
    value_vars=[col for col in Aprovacao.columns if "VL_APROVACAO" in col],
    var_name="Ano",
    value_name="APROVACAO",
)
Aprovacao["Ano"] = Aprovacao["Ano"].str.extract(r"(\d+)")

Notas = DesempenhoTotal[[*DesempenhoTotal.columns[:2], *[col for col in DesempenhoTotal.columns if 'NOTA_MATEMATICA' in col or 'NOTA_PORTUGUES' in col]]]

matematica = Notas.melt(
    id_vars=["UNIDGEO", "NIVEL"],
    value_vars=[col for col in Notas.columns if "NOTA_MATEMATICA" in col],
    var_name="Ano",
    value_name="MATEMATICA",
)
portugues = Notas.melt(
    id_vars=["UNIDGEO", "NIVEL"],
    value_vars=[col for col in Notas.columns if "NOTA_PORTUGUES" in col],
    var_name="Ano",
    value_name="PORTUGUES",
)

# Ajustar a coluna de anos para conter apenas o número
matematica["Ano"] = matematica["Ano"].str.extract(r"(\d+)")
portugues["Ano"] = portugues["Ano"].str.extract(r"(\d+)")

# Combinar os dados em um único DataFrame
Notas = pd.merge(
    matematica,
    portugues,
    on=["UNIDGEO", "NIVEL", "Ano"],
    how="inner",
)

df_notas_com_soma = Notas
df_notas_com_soma['SOMA_NOTAS'] = df_notas_com_soma['MATEMATICA'] + df_notas_com_soma['PORTUGUES']

df_map = long_df
df_map["DISCREPANCIA"] = df_map["Observado"] - df_map["Projetado"]

ranking_df = long_df.rename(columns={'Observado': 'Ideb'})
ranking_df = ranking_df.drop(columns={'Projetado'})

ranking_df['Posição'] = ranking_df.groupby(['NIVEL', 'Ano'])['Ideb'].rank(method='min', ascending=False)

estados = sorted(Aprovacao["UNIDGEO"].unique())

anos = sorted(Notas["Ano"].unique())

# Gerando página HTML
def gerandoHtml():
    # Layout do app
    app.layout = html.Div([
        html.Div([
          html.Div([
            html.H2("Desempenho escolar no Brasil", style={"font-family": "Roboto", "color": "#003366"}),
            html.Nav([
                dcc.Link("Ranking IDEB", href="#ideb_ranking", style={"text-decoration": "none", "color": "#003366", "font-family": "Roboto", "font-size": "16px", "padding": "10px"}),
                dcc.Link("Índices", href="#indices", style={"text-decoration": "none", "color": "#003366", "font-family": "Roboto", "font-size": "16px", "padding": "10px"}),
                dcc.Link("Discrepâncias", href="#ideb_discrepancias", style={"text-decoration": "none", "color": "#003366", "font-family": "Roboto", "font-size": "16px", "padding": "10px"}),
                dcc.Link("Taxa de Aprovação", href="#taxa_aprovacao", style={"text-decoration": "none", "color": "#003366", "font-family": "Roboto", "font-size": "16px", "padding": "10px"}),
                dcc.Link("Notas", href="#notas", style={"text-decoration": "none", "color": "#003366", "font-family": "Roboto", "font-size": "16px", "padding": "10px"})
            ], style={"display": "flex", "gap": "15px", "justify-content": "flex-start", "align-items": "center"})
          ], style={"max-width": "1200px", "margin": "0 auto"}),
        ], id='header', style={"background-color": "#f0f0f0", "border-bottom": "2px solid #ddd"}),


        html.Div([
            # Ranking
            html.Div([
                html.H4("Ranking IDEB por estado"),
                html.Div([
                  dcc.RadioItems(
                      id="ranking_nivel_de_ensino",
                      options=[
                          {"label": "Fundamental Anos Iniciais", "value": "Anos Iniciais"},
                          {"label": "Fundamental Anos Finais", "value": "Anos Finais"},
                          {"label": "Ensino Médio", "value": "Ensino Médio"},
                      ],
                      value="Anos Iniciais",
                      inline=True,
                      style={"margin-right": "20px"}
                  ),
                  dcc.Dropdown(
                      id="estado_destaque",
                      placeholder="Escolha um estado para destacar",
                      clearable=True,
                      style={"width": "300px"}
                  ),
                ], style={"display": "flex", "align-items": "center", "gap": "10px", "margin-bottom": "10px"}, id="ranking"),
                dcc.Graph(id="grafico_barra"),
            ], id='ideb_ranking', style=styleDict),

            # indices
            html.Div([
                html.H4("Evolução do Índice Observado e Projetado por Nível de Ensino"),
                dcc.RadioItems(
                    id="nivel_de_ensino",
                    options=[
                        {"label": "Fundamental Anos Iniciais", "value": "Anos Iniciais"},
                        {"label": "Fundamental Anos Finais", "value": "Anos Finais"},
                        {"label": "Ensino Médio", "value": "Ensino Médio"},
                    ],
                    value="Anos Iniciais",
                    inline=True,
                    style={"margin-bottom": "10px"}
                ),
                dcc.Graph(id="mapa")
            ],id = 'indices', style=styleDict),

            # Mapas discrepancia
            html.Div([
                html.H4("Mapa de Discrepâncias por Nível de Ensino"),
                dcc.Graph(id="mapas_discrepancias")
            ],id = 'ideb_discrepancias', style=styleDict),

            # Taxa de aprovação
            html.Div([
                html.H4("Taxa de Aprovação por Estado e Ano"),
                html.Label("Selecione um Estado:"),
                dcc.Dropdown(
                    id="estado-dropdown",
                    options=[{"label": estado, "value": estado} for estado in estados],
                    value=estados[0],  # Valor inicial
                    style={"width": "50%"}
                ),
                dcc.Graph(id="grafico-aprovacao"),
            ], style=styleDict),

            # Notas
            html.Div([
                html.H4("Evolução das Notas por Nível de Ensino"),
                dcc.RadioItems(
                    id="notas_nivel_de_ensino",
                    options=[
                        {"label": "Fundamental Anos Iniciais", "value": "Anos Iniciais"},
                        {"label": "Fundamental Anos Finais", "value": "Anos Finais"},
                        {"label": "Ensino Médio", "value": "Ensino Médio"},
                    ],
                    value="Anos Iniciais",
                    inline=True,
                    style={"margin-bottom": "10px"}
                ),
                dcc.Graph(id="notas_mapa")
            ], style=styleDict)
        ], id='graphics', style={"max-width": "1200px", "margin": "0 auto", "padding": "0px", "font-family": "Roboto", "color": "#333"})
    ])

# Ranking

def graficoRanking():

    @app.callback(
        Output("estado_destaque", "options"),
        Input("ranking_nivel_de_ensino", "value")
    )
    def atualizar_opcoes_dropdown(nivel):
        estados = ranking_df[ranking_df['NIVEL'] == nivel]['UNIDGEO'].unique()
        return [{"label": estado, "value": estado} for estado in estados]

    @app.callback(
        Output("grafico_barra", "figure"),
        [Input("ranking_nivel_de_ensino", "value"),
        Input("estado_destaque", "value")]
    )

    def atualizar_grafico(nivel, estado_destaque):
        filtered_df = ranking_df[ranking_df['NIVEL'] == nivel]

        # Encontrar a maior e menor nota e calcular o valor para o eixo X
        maior_nota = filtered_df['Ideb'].max()
        eixo_x_max = math.ceil(maior_nota)  # Arredondar para o próximo inteiro
        menor_nota = filtered_df['Ideb'].min()
        eixo_x_min = math.floor(menor_nota)  # Arredondar para o anterior inteiro
        if eixo_x_min==menor_nota: eixo_x_min -= 1

        # Adicionar a cor das barras
        filtered_df['color'] = filtered_df['UNIDGEO'].apply(
            lambda estado: 'red' if estado == estado_destaque else 'lightblue'
        )

        fig = px.bar(
            filtered_df,
            x='Ideb',
            y='UNIDGEO',
            text='UNIDGEO',
            animation_frame="Ano",  # Animação com base no ano
            labels={'UNIDGEO': 'Estado'},
            range_x=[2.5, eixo_x_max],  # Ajustando o intervalo do eixo X para 0 até o valor arredondado
            color='color',
            color_discrete_map={"red": "red", "lightblue": "#636EFA"},
            hover_data={'color': False,
                        'UNIDGEO': False,
                        'Ano': False,
                        'Posição': True,
                        'Ideb': True}
        )

        fig.update_layout(
            width=None,
            margin={"r":0,"t":0,"l":0,"b":0},
            height=720,  # Ajuste da altura
            bargap=0.01,  # Diminui o espaço entre as barras
            yaxis=dict(
                categoryorder='total ascending',  # Ordenação dos estados
                showticklabels=False,
                title_font=dict(size=11)
            ),
            xaxis=dict(
                range=[eixo_x_min, eixo_x_max],  # Atualiza o intervalo do eixo X
                title_font=dict(size=11)
            ),
            showlegend=False
        )

        fig.write_html(f"mapa_interativo_{nivel}.html")

        return fig

# Observado e projetado

def graficoIDEB():
    @app.callback(
        Output("mapa", "figure"),
        Input("nivel_de_ensino", "value")
    )

    def atualizar_mapa(nivel):
        dados_filtrados = long_df[long_df['NIVEL'] == nivel]

        min_val = math.floor(min(dados_filtrados[['Observado', 'Projetado']].min()))
        max_val = math.ceil(max(dados_filtrados[['Observado', 'Projetado']].max()))

        fig = px.scatter(
            dados_filtrados,
            x="Projetado",
            y="Observado",
            animation_frame="Ano",
            color="UNIDGEO",
            hover_name="UNIDGEO",
            labels={"UNIDGEO": ""},
            range_x=[min_val, max_val],
            range_y=[min_val, max_val],
            hover_data={"UNIDGEO": False, "Ano": False, "Observado": True, "Projetado": True}
        )

        fig.update_layout(
            width=None,
            height=600,
            margin={"r":0,"t":0,"l":0,"b":0},
        )

        fig.add_shape(
            type="line",
            x0=min_val, y0=min_val,
            x1=max_val, y1=max_val,
            line=dict(color="red", width=2, dash="dash"),
        )

        fig.add_trace(
            dict(
                x=[None],
                y=[None],
                mode="lines",
                line=dict(color="red", width=2, dash="dash"),
                showlegend=True,
                name="Observado = Projetado"
            )
        )

        fig.update_traces(marker=dict(size=10))

        fig.write_html(f"observado_projetado_{nivel}.html")

        return fig

# Mapa de Discrepâncias entre Notas Observadas e Projetadas por Estado

def graficoDiscrepancia():
    @app.callback(
        Output("mapas_discrepancias", "figure"),
        Input("nivel_de_ensino", "value")

    )
    def mapas_discrepancias(nivel):

        fig = px.choropleth(
            df_map,  # Usando o DataFrame completo
            geojson="https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson",
            locations="UNIDGEO",
            featureidkey="properties.name",
            color="DISCREPANCIA",
            hover_name="UNIDGEO",
            animation_frame="Ano",
            color_continuous_scale="RdBu",
            color_continuous_midpoint=0,  # Define o ponto médio como zero
            labels={"DISCREPANCIA": "Discrepância"},
            facet_col="NIVEL",
            facet_col_wrap=3,
            facet_col_spacing=0.001,
            facet_row_spacing=0.001,
            category_orders={"NIVEL": ["Anos Iniciais", "Anos Finais", "Ensino Médio"]},
            hover_data={"DISCREPANCIA": True, "NIVEL": False, "Ano": False, "UNIDGEO": False},
        )
        # Ajustar os títulos das facetas para remover o prefixo "NIVEL="
        fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1]))

        # Ajustar o layout do mapa
        fig.update_geos(
            fitbounds="locations",
            visible=False,
            #showframe=True
        )
        # Personalizar a barra de legenda (colorbar) acima do gráfico
        fig.update_layout(
            width=None,
            height=600,
            margin={"r":0,"t":0,"l":0,"b":0},
            coloraxis_colorbar=dict(
                orientation="h",  # Mantém a orientação horizontal
                x=0.5,  # Centraliza horizontalmente
                xanchor="center",  # Define o ponto de referência horizontal
                y=1.2,  # Posiciona a barra acima do gráfico
                yanchor="bottom",  # Define o ponto de referência vertical
                thickness=10,  # Reduz a altura (espessura) da barra
                len=0.3,  # Reduz o comprimento da barra
                title="Discrepância",  # Título acima da barra
                title_side="top",  # Coloca o título acima da barra
            )
        )
        fig.write_html(f"mapas_discrepancias.html")

        return fig

# Taxa de aprovação

def graficoTaxaAprovacao():
    # Callback para atualizar o gráfico com base no estado selecionado
    @app.callback(
        Output("grafico-aprovacao", "figure"),
        Input("estado-dropdown", "value")
    )
    def update_graph(estado_selecionado):
        # Filtrar o dataframe pelo estado selecionado
        df_filtrado = Aprovacao[Aprovacao["UNIDGEO"] == estado_selecionado]

        # Criar o gráfico
        fig = px.line(
            df_filtrado,
            x="Ano",
            y="APROVACAO",
            color="NIVEL",
            labels={"APROVACAO": "Taxa de Aprovação (%)", "Ano": "Ano", "NIVEL": "Nível"},
            range_y=[60,100]
        )

        fig.update_layout(
            width=None,
            height=600,
            margin={"r":0,"t":0,"l":0,"b":0}
        )

        return fig

# Notas de português e matemática
def graficoNotas():
    @app.callback(
        Output("notas_mapa", "figure"),
        Input("notas_nivel_de_ensino", "value")
    )
    def update_map(nivel_selecionado):
        # Filtrar o DataFrame pelo nível selecionado
        df_filtrado = df_notas_com_soma[df_notas_com_soma['NIVEL'] == nivel_selecionado]

        # Calcular nota mínima e máxima para manter a escala de cores consistente
        nota_min = df_filtrado['SOMA_NOTAS'].min()
        nota_max = df_filtrado['SOMA_NOTAS'].max()

        # Criar o gráfico
        fig = px.choropleth(
            df_filtrado,
            geojson="https://raw.githubusercontent.com/codeforamerica/click_that_hood/master/public/data/brazil-states.geojson",
            locations="UNIDGEO",
            featureidkey="properties.name",
            color="SOMA_NOTAS",
            hover_name="UNIDGEO",
            animation_frame="Ano",
            color_continuous_scale="RdBu",
            range_color=[nota_min, nota_max],
            labels={"SOMA_NOTAS": "Matemática + Português"},
            title="Mapa das Notas por Nível de Ensino"
        )

        # Ajustar o layout do mapa
        fig.update_geos(
            fitbounds="locations",
            visible=False
        )

        fig.update_layout(
            width=None,
            height=600,
            margin={"r":0,"t":0,"l":0,"b":0}
        )

        return fig

# Executar o servidor
app = Dash(__name__)

gerandoHtml()
graficoRanking()
graficoIDEB()
graficoDiscrepancia()
graficoTaxaAprovacao()
graficoNotas()

if __name__ == "__main__":
    app.run_server(debug=True)